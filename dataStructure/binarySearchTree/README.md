Lists - linear
Trees - nonlinear

루트가 2개 이상이면 트리 구조가 아님

### BST

- 모든 부모 노드는 최대 2개의 자식을 가짐
- 부모 노드의 왼쪽에 있는 모든 노드는 부모 쪽보다 작고 오른쪽에 있는 모든 노드는 부모 쪽보다 큼

### BFS

같은 레벨에 있는 모든 노드를 거쳐야 한다.

- 큐 자료구조 이용
- 루트를 가지고 큐에 넣기
- 큐에 값이 있다면 계속 루프 돌리기
- 큐에서 dequeue(배열이라면 shift 메소드)
- 그 노드를 가지고 리스트에 추가
- 그 노드에 왼쪽 값이 있으면 큐에 넣고 오른쪽 값이 있으면 큐에 넣기
- 가장 마지막에 루프가 끝난 다음 모든 값을 저장한 변수 출력

### DFS

형제 노드(같은 레벨)로 넘어가기 전에 수직으로 트리의 끝까지 내려간다.

#### 전위 탐색

먼저 루트에 방문한 다음 왼쪽을 전부 순회한 다음에 오른쪽을 순회한다.

#### Step

1. 방문한 노드 값을 저장하는 변수를 만든다.
2. current라고 하는 이름의 변수를 만든 다음 루트에 저장한다.
3. help function을 이용해서 노드의 값읇 변수에 넣어서 저장. 그 이후에 노드를 방문해서 배열이나 리스트에 값 추가한다.
4. 만약 노드가 left 프로퍼티를 가진다면, 재귀 방식으로 help function을 호출한다.

#### 후위 탐색

전위 탐색과는 다르게 루트 노드를 나중에 방문하고 그 전에 오른쪽과 왼쪽을 순서대로 돈다.

### DFS vs BFS?

우선 시간복잡도는 BFS,DFS 모두 노드를 한번씩 방문하기 때문에 서로 같다.

트리에 상태에 따라 적절하게 사용해야 한다.

깊이보다 너비가 넓은 트리를 작업한다면 DFS가 더 낫다.(공간적으로)

![](https://velog.velcdn.com/images/gktmd652/post/fb0acbc6-b367-4c6e-8a34-a43789085ba4/image.png)
